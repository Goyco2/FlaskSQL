3. creare le tabelle con le varie primary key ma senza le foreign key e permettendo che tutti i campi possano essere null.

create table ricetta(

    id int identity(0,1) primary key,

    nome varchar(255),

    tempo_c int,

    tempo_p int,

    difficolta varchar(20),

    procedimento varchar(255)

)

create table appartiene(

    um varchar(255),

    quantita int,

)

4. modificare le tabelle appena create aggiungendo le foreign key necessarie

alter table appartiene

add id_ric int foreign key references ricetta(id)

5. aggiungere le informazioni riguardanti le calorie della ricetta

alter table

add calorie int

6 a. inserire le seguenti informazioni presenti nella rivista pubblicata nel febbraio del 2019: a pagina 34 è stata pubblicata la ricetta della foto iniziale.

insert into ricetta(nome ,tempo_c,tempo_p,difficolta,procedimento)

values('nome ricetta', 25, 25,'media','cucinare...')

7. modificare la quantità di radicchio tardivo della ricetta del “Dentice al forno” portandolo a 100 gr

update appartiene

set quantita = 100, um='gr'

where id_ric = (select id from ricetta where nome = 'Dentice al forno in crosta di mandorle') and 

id_ing = (select id from ingridiente where nome = 'radicchio')

8. visualizzare

a. i nomi delle ricette che hanno tra gli ingredienti il pangrattato. Visualizzare anche il mese e

l’anno della rivista in cui si trova la ricetta.

select ricetta.nome,rivista.anno,rivista.n_rivista

from ricetta inner join appartiene

on ricetta.id = appartiene.id_ric

inner join ingridiente

on appartiene.id_ing = ingridiente.id

inner join appartiene2

on ricetta.id = appartiene2.id_ric

inner join rivista

on appartiene2.id_riv = rivista.id

where ingridiente.nome = 'pangrattato'

b. i nomi delle ricette che utilizzano almeno 70 gr di pangrattato. Visualizzare anche il mese e

l’anno della rivista in cui si trova la ricetta.

select ricetta.nome,rivista.anno,rivista.n_rivista

from ricetta inner join appartiene

on ricetta.id = appartiene.id_ric

inner join ingridiente

on appartiene.id_ing = ingridiente.id

inner join appartiene2

on ricetta.id = appartiene2.id_ric

inner join rivista

on appartiene2.id_riv = rivista.id

where ingridiente.nome = 'pangrattato' and appartiene.quantita >=70

c. i nomi delle ricette dove non c’è il latte

select nome 

from ricetta

where ricetta.id not in 

( select ricetta.id from ricetta inner join appartiene

on ricetta.id = appartiene.id_ric

inner join ingridiente

on appartiene.id_ing = ingridiente.id

where ingridiente.nome ='latte')

e. il numero di ingredienti per ogni ricetta

select ricetta.nome, count(appartiene.id) as tot_ing

from from ricetta inner join appartiene

on ricetta.id = appartiene.id_ric

group by ricetta.nome (incompleto mi sa)





 1)nominativi dei clienti che hanno una mail di gmail

select first_name, last_name, email

from sales.customers

where email like '%@gmail.%'

2) nomi cognomi dei clienti che non abitano a NeW York

select first_name, last_name

from sales.customers

where city != 'New York'

3) lo sconto piu alto effetuato su un prodotto

select max(discount) * 100 as sconto_alto

from sales.order_items

4) gli ordini che sono stati già consegnati

select *

from sales.orders

where shipped_date is not null

5) gli ordini che non sono ancora stati spediti

select *

from sales.orders

where shipped_date is null

6) i prodotti acquistati da Martin Spencer

select production.products.*

from sales.customers inner join sales.orders

on sales.customers.customer_id = sales.orders.customer_id

inner join sales.order_items

on sales.orders.order_id = sales.order_items.order_id

inner join production.products

on sales.order_items.product_id = production.products.product_id

where first_name = 'Johnathan' and last_name ='Velazquez'

oppure

-- i prodotti acquistati da Martin Spencer

select p.*

from sales.customers as C inner join sales.orders as O

on C.customer_id = O.customer_id

inner join sales.order_items as OI

on O.order_id = OI.order_id

inner join production.products as P

on OI.product_id = P.product_id

where first_name = 'Johnathan' and last_name ='Velazquez'

7) nominativi e le mail dei clienti che abitano in California e in Texas

select *

from sales.customers

where state = 'CA' or state = 'TX'

oppure 

-- nominativi e le mail dei clienti che abitano in California e in Texas

select *

from sales.customers

where state in ('CA', 'TX')

8) il numero di ordini per ogni cliente

select first_name, last_name, count(*) as numero_ordini

from sales.orders inner join sales.customers

su sales.customers.customer_id = sales.orders.customer_id

-- non si fa il gruppo per con il nome e cognome perche ci potrebbe essere 2 clienti con lo stesso nome o cognome

raggruppa per sales.customers.customer_id, first_name, last_name

ordina per numero_ordini disc

9) numero di dipendenti in ogni punto vendita

seleziona store_name, count(*) come numero_dipendenti

from sales.stores inner join sales.staffs

su sales.stores.store_id = sales.staffs.store_id

raggruppa per sales.staffs.store_id, store_name

10) il nome e il cognome dei clienti che hanno effettuato più di 50 ordini

seleziona first_name, last_name , count(order_status) come tot_ordini

da sales.customers inner join sales.orders

su sales.customers.customer_id = sales.orders.customer_id

raggruppare per nome, cognome

avendo conteggio (stato_ordine) >= 50

seleziona first_name, last_name , count(order_status) come tot_ordini

da sales.customers inner join sales.orders

su sales.customers.customer_id = sales.orders.customer_id

raggruppare per nome, cognome

avendo conteggio(stato_ordine) >= 2

11) il nome dello store con piu dipendenti

seleziona store_name, count(first_name) come tot_dipendenti

from sales.stores inner join sales.staffs

su sales.stores.store_id = sales.staffs.store_id

raggruppa per nome_negozio

avendo count(first_name) = ( seleziona max(tot_dipendenti)

da (seleziona store_name, count(first_name) come tot_dipendenti

from sales.stores inner join sales.staffs

su sales.stores.store_id = sales.staffs.store_id

raggruppa per nome_negozio) come tot)

12) il nome e il cognome del gestore

seleziona nome, cognome, id_gestore

dal personale di vendita

dove manager_id non è nullo







3a) gradimento medio dell’episodio ‘la scatola del bravo ragazzo’ della serie Dahmer

select avg(guarda.valutazione) as medio

from episodio inner join serie

on episodio.idS = serie.id

inner join guarda 

on guarda.idE = episodio.id

where serie.nome = ‘Dahmer’

and episodio.titolo = ‘la scatola del bravo ragazzo’

oppure

select avg(garda.valutazione) as medio

from guarda

where idE = (select id from episodio

where nome = ‘la scatola del bravo ragazzo’

and idS = (select id from serie

where nome=’Dahmer’)

3b) elenco serie con il numero degli episodi

select serie.id, serie.nome, count(*) as n_ep

from serie inner join episodio

on serie.id = episodio.idS

group by serie.id, serie.nome

3c) utenti che hanno guardato piu di 100 episodi

select utente.nome, utente.cognome, count(*) as n_ep

from utente inner join guarda

on utente.id = guarda.idU

group by utente.id, utente.nome, utente.cognome

having count(*) > 100

order by n_ep desc

3d) elenco utenti(nome, cognome) che hanno guardato piu di 10 serie diverse

(ERRATO DA SISTEMARE)

select utente.nome, utente.cognome, count(serie.id) as tot_serie

from utente inner join guarda

on utente.id = guarda.idU

inner join episodio

on guarda.idE = episodio.id

inner join serie

on episodio.idS = serie.id

group by utente.id, utente.nome, utente.cognome

having count(serie.id) >= 10

3e) elenco degli utenti che nell’ultimo mese non hanno guardato la serie Dahmer

select * from utente

where utente.id not in

(select utente.id

from utente inner join guarda

on utente.id = guarda.idU

inner join episodio

on guarda.idE = episodio.id

inner join serie

on episodio.idS = serie.id

where serie.nome = ‘Dahmer’ and datediff(day, guarda.date, getdate())< 30) → utenti che hanno guardato

4a) avere elenco della serie di genere drammatico e fantascientifico ordinato in ordine alfabetico visualizzando prima la serie fantascienza poi drammatico

select * 

from serie inner join app2

on serie.id = app2.idS

inner join genere

on app2.idG = genere.id

where genere.genere =’drammatico’ or genere.nome =’fantascienza’

– where genere.nome in (‘drammatico’,’fantascienze’)

order by genere.genere desc, serie.nome

4b) elenco degli episodi(titolo e serie) in cui ha recitato flavio Nedina. 

pt1

select episodio.titolo, serie.nome

from attore inner join recita

on attore.id = recita.idA

inner join episodio

on episodio.id = recita.idE

inner join serie

on serie.id = episodio.idS

where attore.nome =’Flavio’ and attore.cognome=’Nedina’

pt2 - avere elenco della serie in cui compare la parola ‘the’ all’inizio del nome della serie.

select *

from serie

where nome like ‘The %’

4c) numero utenti che hanno guardato episodi nel settembre del 2022

select count(*) as num_utenti

from utente inner join guarda

on utente.id = guarda.idU

where guarda.data between ‘2022-09-01’and ‘2022-09-31’

5a) creare una tabella che rappresenta un'entità

crea tabella genere(

    id int identity(0,1) come chiave primaria,

    genere varchar(255)

)

5b) creare una tabella che rappresenta una relazione

crea tabella app2(

    idS int riferimenti a chiavi esterne serie(id),

    idG int riferimenti a chiavi esterne genere(id)

)

5c) aggiungere un campo numero di telefono all'utente

modifica la tabella utente

aggiungi telefono varchar(20)

5d) eliminare l'attributo sesso dall'utente

modifica la tabella utente

colonna a goccia sesso

5e) eliminare gli utenti a cui è scaduto l'abbonamento

elimina da utente

dove data_fine_abb < getdate()

5f) modificare la valutazione degli ep da 1 a 10 a 1 a 5 stelle,es:





altera tavola guarda

altera colonna guarda decimale(2,1)

aggiorna guarda

imposta valutazione = valutazione/2

aggiorna guarda

impostare valutazione = 1

dove valutazione = 0,5
